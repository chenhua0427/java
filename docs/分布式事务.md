

##### 概述

2pc、3pc、Tcc、最终一致性。

##### 消息发送一致性保证

- 问题：发送消息和业务处理两个方法如何保证同时成功同时失败？

  ~~~java
  public void completeOrder(){
      orderDao.process();//订单业务方法
      sendMessage();//发送消息，通知下游业务处理
  }
  ~~~

- 解决：

  1. 发送消息到MQ，消息状态为待确认，MQ消息持久化
  2. 返回消息创建结果；
  3. 执行业务操作，并将结果通知MQ
  4. 第四步，MQ投递消息。

##### 消息发送一致性流程中异常

- TM发送待确认消息异常
- MQ存储消息异常
- 返回消息创建结果给TM异常
- TM发送业务处理结果给MQ异常
- MQ处理待确认消息异常

<font color="#8B0000">不一致情况</font>：

- 消息已存储(待确认)，业务操作未执行

  ~~~
  MQ主动确认根据待处理消息，确认TM业务操作，删除消息
  ~~~

- 业务操作已执行，消息未发送

  ~~~
  MQ主动确认根据待处理消息，确认TM业务操作，投递消息
  ~~~

- 异常处理异常

  ~~~
  重复执行：MQ主动确认根据待处理消息，确认TM业务操作
  ~~~

##### 消息重复发送问题及接口幂等

##### 可靠性最终一致性方案

- 本地消息服务

  ~~~yml
  在业务数据库的消息表中存储了消息，能够保证消息一定能发送成功 #对MQ要求不高，只用到消息发送功能
  ~~~

- <font color="#1E90FF">独立消息服务</font>

  ![transactional_mq1](E:\note\docs\image\transactional_mq1.png)

  - 消息服务子系统

    ~~~java
    消息发送一致性的正向流程：存储消息到服务库；投递消息给/*实时消息服务*/；提供接口供其它系统调用
    ~~~

  - 消息状态确认子系统

    ~~~java
    处理消息发送一致性的异常：定时轮询，调用接口 /*消息服务子系统 查询状态确认超时的消息*/ 
    ~~~

  - 实时消息服务

    ~~~java
    MQ：供消息业务消费端消费消息ack。
    业务消费端同时调用接口 /*消息服务子系统 确认消息已被成功消费*/ （消息服务子系统就会删除消息服务库中的消息）
    ~~~

  - 消息恢复子系统

    ~~~java
    处理消息消费异常：定时轮询，调用 /*消息服务子系统 查询消费确认超时的消息*/查询已经投递但未ack的消息，并将其重新投递到 /*实时消息服务*/
    ~~~